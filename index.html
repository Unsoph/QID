<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Aadhaar Card Detection with Orientation Correction</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      background: #ffffff;
      max-width: 1200px;
      margin: 0 auto;
    }
    
    .upload-section {
      background: #f8f9fa;
      border: 2px dashed #dee2e6;
      border-radius: 10px;
      padding: 20px;
      text-align: center;
      margin: 20px 0;
    }
    
    #image-input {
      margin: 10px 0;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 5px;
    }
    
    #output-canvas {
      display: block;
      margin: 20px auto;
      border: 2px solid #ccc;
      border-radius: 10px;
      max-width: 100%;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    
    .info-box {
      background: #e3f2fd;
      border: 1px solid #2196f3;
      border-radius: 5px;
      padding: 15px;
      margin: 15px 0;
    }
    
    .status {
      font-weight: bold;
      padding: 5px 0;
    }
    
    .loader {
      display: none;
      text-align: center;
      color: #007bff;
      font-weight: bold;
      font-size: 18px;
      margin: 20px 0;
    }
    
    .error {
      background: #ffebee;
      border: 1px solid #f44336;
      color: #c62828;
      padding: 10px;
      border-radius: 5px;
      margin: 10px 0;
    }
  </style>
</head>
<body>
  <h1>üÜî Aadhaar Card Detector</h1>
  <p>Upload an image to automatically detect and extract Aadhaar cards with orientation correction</p>

  <div class="upload-section">
    <label for="image-input">üìÅ Choose Image File:</label><br>
    <input type="file" id="image-input" accept="image/*" />
  </div>

  <div class="info-box">
    <div id="rotation-info" class="status">üìê Rotation: Ready</div>
    <div id="detection-info" class="status">üéØ Detections: Ready</div>
    <div id="model-status" class="status">ü§ñ Model: Loading...</div>
  </div>
  
  <div id="loader" class="loader">üîÑ Processing image...</div>
  <div id="error-box" class="error" style="display: none;"></div>
  <canvas id="output-canvas"></canvas>

  <!-- ONNX Runtime Web -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/onnxruntime-web/1.14.0/ort.min.js"></script>

  <script>
    // Global variables
    const imageInput = document.getElementById('image-input');
    const canvas = document.getElementById('output-canvas');
    const ctx = canvas.getContext('2d');
    const rotationInfo = document.getElementById('rotation-info');
    const detectionInfo = document.getElementById('detection-info');
    const modelStatus = document.getElementById('model-status');
    const loader = document.getElementById('loader');
    const errorBox = document.getElementById('error-box');
    let session;

    // Aadhaar keywords for orientation detection
    const AADHAAR_KEYWORDS = [
        "government of india", "govt of india", "dob", "year of birth",
        "male", "female", "vid", "aadhaar", "‡§Ü‡§ß‡§æ‡§∞", "‡§≠‡§æ‡§∞‡§§ ‡§∏‡§∞‡§ï‡§æ‡§∞"
    ];

    // Utility functions
    function showError(message) {
      errorBox.textContent = message;
      errorBox.style.display = 'block';
      console.error(message);
    }

    function hideError() {
      errorBox.style.display = 'none';
    }

    function showLoader() {
      loader.style.display = 'block';
    }

    function hideLoader() {
      loader.style.display = 'none';
    }

    // Initialize ONNX model
    async function init() {
      try {
        modelStatus.textContent = 'ü§ñ Model: Loading...';
        // Updated path for Vercel deployment
        session = await ort.InferenceSession.create('/best.onnx');
        modelStatus.textContent = 'ü§ñ Model: Ready ‚úÖ';
        console.log("ONNX model loaded successfully");
      } catch (error) {
        const errorMsg = `Failed to load ONNX model: ${error.message}`;
        modelStatus.textContent = 'ü§ñ Model: Failed ‚ùå';
        showError(errorMsg);
      }
    }

    // Rotate image by specified angle
    function rotateImage(image, angle) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      if (angle === 0) {
        canvas.width = image.width || image.naturalWidth;
        canvas.height = image.height || image.naturalHeight;
        ctx.drawImage(image, 0, 0);
        return canvas;
      }
      
      const w = image.width || image.naturalWidth;
      const h = image.height || image.naturalHeight;
      
      if (angle === 90 || angle === 270) {
        canvas.width = h;
        canvas.height = w;
      } else {
        canvas.width = w;
        canvas.height = h;
      }
      
      ctx.translate(canvas.width / 2, canvas.height / 2);
      ctx.rotate((angle * Math.PI) / 180);
      ctx.drawImage(image, -w / 2, -h / 2);
      
      return canvas;
    }

    // Calculate image sharpness score
    function calculateSharpnessScore(canvas) {
      const ctx = canvas.getContext('2d');
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      
      const gray = [];
      for (let i = 0; i < data.length; i += 4) {
        gray.push(0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]);
      }
      
      let laplacianSum = 0;
      const width = canvas.width;
      const height = canvas.height;
      
      for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
          const idx = y * width + x;
          const laplacian = 
            -gray[idx - width - 1] - gray[idx - width] - gray[idx - width + 1] +
            -gray[idx - 1] + 8 * gray[idx] - gray[idx + 1] +
            -gray[idx + width - 1] - gray[idx + width] - gray[idx + width + 1];
          laplacianSum += laplacian * laplacian;
        }
      }
      
      return laplacianSum / ((width - 2) * (height - 2));
    }

    // Detect text orientation using edge detection
    function detectTextOrientation(canvas) {
      const ctx = canvas.getContext('2d');
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const width = canvas.width;
      const height = canvas.height;
      
      const gray = new Uint8Array(width * height);
      for (let i = 0; i < data.length; i += 4) {
        gray[i / 4] = Math.round(0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]);
      }
      
      let horizontalEdges = 0;
      let verticalEdges = 0;
      
      for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
          const idx = y * width + x;
          
          const gx = 
            -gray[idx - width - 1] + gray[idx - width + 1] +
            -2 * gray[idx - 1] + 2 * gray[idx + 1] +
            -gray[idx + width - 1] + gray[idx + width + 1];
          
          const gy = 
            -gray[idx - width - 1] - 2 * gray[idx - width] - gray[idx - width + 1] +
            gray[idx + width - 1] + 2 * gray[idx + width] + gray[idx + width + 1];
          
          const magnitude = Math.sqrt(gx * gx + gy * gy);
          if (magnitude > 50) {
            if (Math.abs(gx) > Math.abs(gy)) {
              verticalEdges++;
            } else {
              horizontalEdges++;
            }
          }
        }
      }
      
      return { horizontalEdges, verticalEdges };
    }

    // Find the best orientation
    async function findBestOrientation(image) {
      console.log("üîÑ Analyzing image orientation...");
      
      const rotations = [0, 90, 180, 270];
      const scores = [];
      
      for (const angle of rotations) {
        const rotatedCanvas = rotateImage(image, angle);
        const sharpnessScore = calculateSharpnessScore(rotatedCanvas);
        const edgeInfo = detectTextOrientation(rotatedCanvas);
        const edgeScore = edgeInfo.horizontalEdges > edgeInfo.verticalEdges ? 100 : 0;
        const totalScore = sharpnessScore + edgeScore;
        
        scores.push({ angle, totalScore });
        console.log(`Rotation ${angle}¬∞ ‚Üí Score: ${totalScore.toFixed(1)}`);
      }
      
      const bestRotation = scores.reduce((best, current) => 
        current.totalScore > best.totalScore ? current : best
      );
      
      console.log(`‚úÖ Best orientation: ${bestRotation.angle}¬∞`);
      return bestRotation.angle;
    }

    // Apply orientation correction
    async function correctOrientation(image) {
      const bestAngle = await findBestOrientation(image);
      rotationInfo.textContent = `üìê Rotation: ${bestAngle}¬∞ applied`;
      
      if (bestAngle === 0) {
        return image;
      }
      
      const correctedCanvas = rotateImage(image, bestAngle);
      return new Promise((resolve) => {
        const correctedImage = new Image();
        correctedImage.onload = () => resolve(correctedImage);
        correctedImage.src = correctedCanvas.toDataURL();
      });
    }

    // Preprocess image for ML model
    function preprocessImage(image) {
      const modelSize = 640;
      const canvasTemp = document.createElement('canvas');
      const ctxTemp = canvasTemp.getContext('2d', { willReadFrequently: true });

      const imgW = image.naturalWidth || image.width;
      const imgH = image.naturalHeight || image.height;
      const scale = Math.min(modelSize / imgW, modelSize / imgH);
      const resizedW = Math.round(imgW * scale);
      const resizedH = Math.round(imgH * scale);

      const padX = Math.floor((modelSize - resizedW) / 2);
      const padY = Math.floor((modelSize - resizedH) / 2);

      canvasTemp.width = modelSize;
      canvasTemp.height = modelSize;

      ctxTemp.fillStyle = 'black';
      ctxTemp.fillRect(0, 0, modelSize, modelSize);
      ctxTemp.drawImage(image, padX, padY, resizedW, resizedH);

      const imageData = ctxTemp.getImageData(0, 0, modelSize, modelSize).data;
      const floatData = new Float32Array(modelSize * modelSize * 3);

      for (let i = 0; i < modelSize * modelSize; i++) {
        floatData[i] = imageData[i * 4] / 255;
        floatData[i + modelSize * modelSize] = imageData[i * 4 + 1] / 255;
        floatData[i + 2 * modelSize * modelSize] = imageData[i * 4 + 2] / 255;
      }

      preprocessImage.lastPadX = padX;
      preprocessImage.lastPadY = padY;
      preprocessImage.lastScale = scale;

      return new ort.Tensor('float32', floatData, [1, 3, modelSize, modelSize]);
    }

    // Non-maximum suppression
    function nonMaxSuppression(boxes, iouThreshold = 0.8) {
      boxes.sort((a, b) => b.conf - a.conf);
      const selected = [];

      for (let i = 0; i < boxes.length; i++) {
        const a = boxes[i];
        let keep = true;

        for (let j = 0; j < selected.length; j++) {
          const b = selected[j];
          const iou = calculateIoU(a, b);
          if (iou > iouThreshold) {
            keep = false;
            break;
          }
        }

        if (keep) selected.push(a);
      }

      return selected;
    }

    // Calculate IoU
    function calculateIoU(a, b) {
      const x1 = Math.max(a.x - a.w / 2, b.x - b.w / 2);
      const y1 = Math.max(a.y - a.h / 2, b.y - b.h / 2);
      const x2 = Math.min(a.x + a.w / 2, b.x + b.w / 2);
      const y2 = Math.min(a.y + a.h / 2, b.y + b.h / 2);

      const interArea = Math.max(0, x2 - x1) * Math.max(0, y2 - y1);
      const boxAArea = a.w * a.h;
      const boxBArea = b.w * b.h;

      return interArea / (boxAArea + boxBArea - interArea);
    }

    // Crop and download function
    function cropAndDownload(image, x, y, w, h, index) {
      const cropCanvas = document.createElement('canvas');
      const cropCtx = cropCanvas.getContext('2d');
      cropCanvas.width = w;
      cropCanvas.height = h;
      cropCtx.drawImage(image, x, y, w, h, 0, 0, w, h);

      cropCanvas.toBlob(blob => {
        const link = document.createElement('a');
        link.download = `aadhaar_crop_${index}.png`;
        link.href = URL.createObjectURL(blob);
        link.click();
        URL.revokeObjectURL(link.href);
      }, 'image/png');
    }

    // Main image upload handler
    async function handleImageUpload(event) {
      if (!session) {
        showError('Model not loaded yet. Please wait and try again.');
        return;
      }

      const file = event.target.files[0];
      if (!file) return;

      hideError();
      showLoader();

      const img = new Image();
      img.onload = async () => {
        try {
          console.log("üì∏ Processing image...");
          
          // Step 1: Correct orientation
          const correctedImg = await correctOrientation(img);
          
          // Step 2: Set up canvas
          canvas.width = correctedImg.naturalWidth || correctedImg.width;
          canvas.height = correctedImg.naturalHeight || correctedImg.height;
          ctx.drawImage(correctedImg, 0, 0);

          // Step 3: Run ML model
          const inputTensor = preprocessImage(correctedImg);
          const feeds = { images: inputTensor };
          const output = await session.run(feeds);
          const outputTensor = output[Object.keys(output)[0]];
          const rawData = outputTensor.data;
          const [, , numDetections] = outputTensor.dims;

          const boxes = [];
          for (let i = 0; i < numDetections; i++) {
            const x = rawData[i];
            const y = rawData[i + numDetections];
            const w = rawData[i + 2 * numDetections];
            const h = rawData[i + 3 * numDetections];
            const conf = rawData[i + 4 * numDetections];

            if (conf > 0.4) {
              boxes.push({ x, y, w, h, conf });
            }
          }

          const finalBoxes = nonMaxSuppression(boxes);
          detectionInfo.textContent = `üéØ Detections: ${finalBoxes.length} Aadhaar card(s) found`;

          // Step 4: Draw results
          ctx.drawImage(correctedImg, 0, 0);

          const scale = 1 / preprocessImage.lastScale;
          const padX = preprocessImage.lastPadX;
          const padY = preprocessImage.lastPadY;

          ctx.strokeStyle = 'lime';
          ctx.lineWidth = 3;
          ctx.font = '16px Arial';
          ctx.fillStyle = 'lime';

          for (let i = 0; i < finalBoxes.length; i++) {
            const box = finalBoxes[i];
            const x = (box.x - padX) * scale;
            const y = (box.y - padY) * scale;
            const w = box.w * scale;
            const h = box.h * scale;
            const left = x - w / 2;
            const top = y - h / 2;

            ctx.strokeRect(left, top, w, h);
            ctx.fillText(`Conf: ${box.conf.toFixed(2)}`, left, top > 20 ? top - 5 : top + 15);

            // Auto-download cropped images
            cropAndDownload(correctedImg, left, top, w, h, i + 1);
          }
          
          console.log("‚úÖ Processing complete!");
          
        } catch (error) {
          showError(`Processing error: ${error.message}`);
        } finally {
          hideLoader();
        }
      };

      img.onerror = () => {
        showError('Failed to load image. Please try a different file.');
        hideLoader();
      };
      
      img.src = URL.createObjectURL(file);
    }

    // Initialize everything
    document.addEventListener('DOMContentLoaded', init);
    imageInput.addEventListener('change', handleImageUpload);
  </script>
</body>
</html>